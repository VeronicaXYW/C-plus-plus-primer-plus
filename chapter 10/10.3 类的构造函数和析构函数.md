普通变量类型和结构体可以直接赋值，类只能访问公有成员。所以如果数据是私有成员，则不能通过如下方式进行赋值：
```
int year = 2001;//可以这样赋值
struct thing
{
	char* pn;
	int m;
};
thing amabob = {"wodget", -23};//可以这样赋值
Stock hot = {...}//无法这样赋值，只能通过hot.acquire(...)
```
如果数据是公有成员，倒是可以直接赋值，但是违背了隐藏数据的目标。

目前大部分程序，如果注册一个新账号，会给出默认的用户名、身份信息，用户可以去修改，也可以沿用。这样用户就不必在一开始提交这么多信息，也不会因为缺少个别不重要的信息（比如用户名）而无法进行进一步操作。
程序声明对象时，自动调用构造函数。
构造函数的创建、使用
构造函数的特征是，虽然没有返回值，但是也不标void
```
原型
Stock(const string& co, long n = 0, double pr = 0.0);

可以这么定义
Stock::Stock(const string& co, long n = 0, double pr = 0.0)
//这里的形参不能使用类成员本身，比如string& company, long shares
//通常使用前后缀来方便辨认+区分
{
	company = co;
	if(n < 0)
	{
		std::cerr << "number of shares can't be negative; "
				<< company << "shares set to 0.\n";
		shares = 0;
	}
	else
		shares = n;
	share_val = pr;
	set_tot();
}

```

当对象过期后，析构函数负责完成清理工作。如果构造函数使用new来分配内存，则析构函数用delete来释放这些内存。
如果像上文中的构造函数那样简单，只要生成一个什么都不做的隐式析构函数即可。
但是要掌握析构函数的声明、定义。
```
创建：
~Stock();
有前缀，没有返回值，也没有形参

定义：
Stock::~Stock()
{
}
```
析构函数什么时候被调用，由编译器决定。如果创建静态存储类对象，则程序结束时自动调用析构函数。如果创建自动存储类对象，则完成代码块时自动调用析构函数。
如果程序员未提供析构函数，编译器将隐式地生成一个析构函数。

加入构造函数和析构函数之后，程序如下所示：
头文件
```

```
实现文件
```

```
客户文件
```
#include<iostream>
#include"stock10.h"

int main()
{
	{
		using std::cout;
		cout << "Using constructors to create new objects\n";
		Stock stock1("nanosmart", 12, 20.0);//第一种赋值方法
		stock1.show();
		Stock stock2 = Stock("boffo objects", 2, 2.0);//第二种赋值方法
		stock2.show();

		cout << "assigning stock1 to stock2:\n";
		stock2 = stock1;
		cout << "listing stock1 and stock2:\n";
		stock1.show();
		stock2.show();

		cout << "using a constructor to reset an object\n";
		stock1 = Stock("nifty foods", 10, 50.0);
		cout << "revised stock1:\n";
		stock1.show();
		cout << "done\n";
	}
	
	return 0;
}
```
一开始我把上一套头文件、实现文件还留在文件夹中，运行后报错# LNK2005，通常，此错误意味着违反了唯一定义规则。我将上一套文件都移除，顺利运行。

总结一下，要使用类，需要头文件、实现文件和客户文件
这三种文件包含什么？
